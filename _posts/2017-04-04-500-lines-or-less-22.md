---
layout:     post
title:      "500 Lines or Less Chapter 21: A Template Engine 翻译"
category:   Translation
tags:       Python Translation
---

* content
{:toc}

[500 Lines or Less](https://github.com/aosabook/500lines)

## 介绍

大多数程序包含很多逻辑和一些文字文字数据。编程语言为此被设计。但是一些编程任务只涉及一点逻辑，还有大量的文本数据。对于这些任务，我们希望有一个更适合这些文本问题的工具。模板引擎是这样一个工具。我们在本章中构建一个简单的模板引擎。

这些重要文本任务之一的最常见的示例是Web应用程序。任何Web应用程序的一个重要阶段是生成HTML以供浏览器使用。很少HTML页面是完全静态的：至少涉及少量的动态数据，如用户名。通常，它们包含大量动态数据：产品列表，新闻更新等。

同时，每个HTML页面都包含大量静态文本。这些页面很大，包含数万字节的文本。Web应用程序开发人员有一个问题需要解决：如何最好地生成一个包含静态和动态数据混合的大型字符串？为了增加问题，静态文本实际上是另一个团队成员（前端设计师）创建的HTML标记，他们希望以熟悉的方式处理它。

为了说明的目的，让我们想象一下HTML内容：

```html
<p>Welcome, Charlie!</p>
<p>Products:</p>
<ul>
    <li>Apple: $1.00</li>
    <li>Fig: $1.50</li>
    <li>Pomegranate: $3.25</li>
</ul>
```

这里用户的名称，产品的名称和价格都是dynamic。即使产品数量不是固定的：可能会有更多或更少的产品显示。

制作这个HTML的一种方法是在我们的代码中加入字符串常量，并将它们合在一起生成页面。动态数据以某种字符串替换插入。我们的一些动态数据是重复的，就像产品列表。这意味着我们将重复一大堆HTML，因此这些HTML不得不单独处理，并与页面的其余部分相结合。

以这种方式生成的页面如下：

```python
# The main HTML for the whole page.
PAGE_HTML = """
<p>Welcome, {name}!</p>
<p>Products:</p>
<ul>
{products}
</ul>
"""

# The HTML for each product displayed.
PRODUCT_HTML = "<li>{prodname}: {price}</li>\n"

def make_page(username, products):
    product_html = ""
    for prodname, price in products:
        product_html += PRODUCT_HTML.format(
            prodname=prodname, price=format_price(price))
    html = PAGE_HTML.format(name=username, products=product_html)
    return html
```

这样做一团糟。HTML在我们的应用程序代码中嵌入了多个字符串常量。很难看到页面的逻辑，因为静态文本被分成单独的部分。数据格式的细节在Python代码中丢失。为了修改HTML页面，我们的前端设计人员需要能够编辑Python代码来修改HTML。想象一下，如果页面是十（或百）倍的复杂程度，代码将是什么样子的？ 它会变得很难工作。

## 模板

制作HTML页面的更好方法是使用模板。HTML页面被制作为一个模板，这意味着这个文件大部分是静态HTML，其动态片段使用特殊的符号进行嵌入。我们上面的页面如下的模板：

```html
<p>Welcome, {{user_name}}!</p>
<p>Products:</p>
<ul>
{% for product in product_list %}
    <li>{{ product.name }}:
        {{ product.price|format_price }}</li>
{% endfor %}
</ul>
```

这里的重点是HTML文本，嵌入在HTML中的逻辑。以文档为中心的方法与上述以逻辑为中心的代码进行对比。我们签名的程序主要是Python，HTML嵌入在Python逻辑中。这里主要是静态HTML标记。

模板中使用的大多数静态样式与大多数编程语言的工作方式相反。例如，使用Python，大部分源文件是可执行的，如果需要文字静态文本，则将其嵌入字符串文字中：

```python
def hello():
    print("Hello, world!")

hello()
```

当Python读取此源文件时，像`def hello()`一样解释文本：作为要执行的指令。`print("Hello, world!")`中的双引号表示以下文字是字面意思，直到关闭双引号。这是大多数编程语言的工作原理：大多是动态的，在指令中嵌入了一些静态片段。静态片用双引号表示。

模板语言翻转：模板文件主要是静态文本文本，用特殊符号表示可执行的动态部分。

```html
<p>Welcome, {{user_name}}!</p>
```

这里的文本表示以字面形式显示在生成的HTML页面中，直到`'{{'`表示切换到动态模式，其中`user_name`变量被替换为输出。

字符串格式化函数，如Python的`"foo = {foo}!".format(foo=17)`用于从字符串文字和要插入的数据创建文本的小型语言的示例。模板扩展了这个想法，包括条件和循环等构造，但差异仅在于程度。

这些文件被称为模板，因为它们用于生成许多具有相似结构但不同细节的页面。

要在我们的程序中使用HTML模板，我们需要一个模板引擎：一个使用描述页面的结构和静态内容的静态模板的函数，以及一个提供动态数据以插入模板的动态上下文。模板引擎结合了模板和上下文来生成一个完整的HTML字符串。模板引擎的工作是解释模板，用实际数据替换动态片段。

顺便说一下，模板引擎中的HTML通常没有什么特别的，它可以用于生成任何文本结果。例如，它们也用于生成纯文本电子邮件。但通常用于HTML，偶尔会具有特定HTML的功能，如转义，这样可以将值插入到HTML中，而不用担心HTML中的哪些字符是特殊的。

## 支持的语法

模板引擎在其支持的语法上有所不同。我们的模板语法是基于流行的Web框架Django。由于我们在Python中实现引擎，因此语法中将会出现一些Python概念。我们已经在本章前面的示例中看到了一些这种语法，但这是我们将要实现的所有语法的一个快速总结。

使用双大括号插入上下文中的数据：

```html
<p>Welcome, {{user_name}}!</p>
```

模板可用的数据在模板的上下文中提供 稍后再说。

模板引擎通常使用简化和轻松的语法提供对数据元素的访问。在Python中，这些表达式都有不同的效果：


```python
dict["key"]
obj.attr
obj.method()
```

在我们的模板语法中，所有这些操作都用一个点表示：

```python
dict.key
obj.attr
obj.method
```

该点访问对象属性或字典值，如果生成的值可调用，则会自动调用它。这与Python代码不同，你需要为这些操作使用不同的语法。这导致更简单的模板语法：

```html
<p>The price is: {{product.price}}, with a {{product.discount}}% discount.</p>
```

您可以使用过滤器函数修改值。使用管道字符调用过滤器：

```html
<p>Short name: {{story.subject|slugify|lower}}</p>
```

构建有趣的页面通常需要少量的决策，因此可用条件语句：

```html
{% if user.is_logged_in %}
    <p>Welcome, {{ user.name }}!</p>
{% endif %}
```

循环让我们在网页中包含数据集合：

```html
<p>Products:</p>
<ul>
{% for product in product_list %}
    <li>{{ product.name }}: {{ product.price|format_price }}</li>
{% endfor %}
</ul>
```

与其他编程语言一样，条件和循环可以嵌套以构建复杂的逻辑结构。

最后，我们记录模板，注释在括号之间显示：

```html
{# This is the best template ever! #}
```

## 方法

模板引擎有两个主要阶段：解析模板，然后呈现模板。

渲染模板具体包括：

1. 管理动态上下文，数据源

2. 执行逻辑元素

3. 实现点访问和过滤器执行

从解析阶段到渲染阶段的过程是关键。解析产生可以呈现的内容？有两个主要选择;我们将把它们称为解释和编译，使用其他语言实现中的宽松术语。

在解释模型中，解析生成表示模板结构的数据结构。渲染阶段沿着该数据结构，根据它找到的指令组装结果文本。一个真实的例子，Django模板引擎使用这种方法。

在编译模型中，解析产生某种形式的直接可执行代码。渲染阶段执行该代码，产生结果。Jinja2和Mako是使用编译方法的模板引擎的两个例子。

我们的引擎实现使用编译：我们将模板编译成Python代码。运行时，Python代码组合结果。

这里描述的模板引擎最初是作为coverage.py的一部分编写的，以生成HTML报告。在coverage.py中，只有几个模板，它们一次又一次地被用于从同一模板生成许多文件。总的来说，如果模板被编译成Python代码，程序运行得更快，因为即使编译过程有点复杂，只需要运行一次，而编译代码的执行运行了很多次，而且比解释速度更快数据结构多次。

将模板编译成Python有点复杂，但并不像你想象的那样糟糕。此外，正如任何开发人员都可以告诉你的，编写程序比编写程序更为有趣！

我们的模板编译器是代码生成的通用技术的小例子。代码生成是强大而灵活的工具，包括编程语言编译器。它可以变得复杂，但是在你的工具箱中是有用的技术。

模板的另一个应用程序可能更喜欢解释的方法，如果模板将仅使用几次。然后，编译到Python从长远来看无法得到回报，而且更简单的解释过程可能会更好地整体运行。

## Python编译

在我们得到模板引擎的代码之前，我们来看看它生成的代码。解析阶段将模板转换为Python函数。这是我们的小模板：

```html
<p>Welcome, {{user_name}}!</p>
<p>Products:</p>
<ul>
{% for product in product_list %}
    <li>{{ product.name }}:
        {{ product.price|format_price }}</li>
{% endfor %}
</ul>
```

我们的引擎将这个模板编译成Python代码。所得到的Python代码并不寻常，因为我们选择了一些快捷方式，这些快捷方式产生的代码稍微快一些。下面是Python代码（稍微重新格式化为可读性）：

```python
def render_function(context, do_dots):
    c_user_name = context['user_name']
    c_product_list = context['product_list']
    c_format_price = context['format_price']

    result = []
    append_result = result.append
    extend_result = result.extend
    to_str = str

    extend_result([
        '<p>Welcome, ',
        to_str(c_user_name),
        '!</p>\n<p>Products:</p>\n<ul>\n'
    ])
    for c_product in c_product_list:
        extend_result([
            '\n    <li>',
            to_str(do_dots(c_product, 'name')),
            ':\n        ',
            to_str(c_format_price(do_dots(c_product, 'price'))),
            '</li>\n'
        ])
    append_result('\n</ul>\n')
    return ''.join(result)
```

每个模板都被转换成`render_function`函数，它接受一个称为上下文的数据字典。函数的主体是将数据从上下文解包为本地名称，因为它们的重复使用速度更快。所有上下文数据都进入有`c_`前缀的本地，以便我们可以使用其他本地名称，而不用担心冲突。

模板的结果是一个字符串。从部分构建字符串的最快方法是创建一个字符串列表，并将它们结合在一起，得到字符串列表。因为我们要添加字符串到这个列表，我们捕获它的附加和扩展方法在本地名称`result_append`和`result_extend`。我们创建的最后一个本地是内置`str`的`to_str`简写。

这些快捷方式是不寻常的。让我们更仔细地看看。在Python中，对象如`result.append("hello")`的方法调用分两步执行。首先，从结果对象中获取`append`属性：`result.append`。然后将所获取的值作为函数调用，传递参数`"hello"`。虽然我们习惯于一起执行这些步骤，但它们其实是分开的。如果保存第一步的结果，可以用保存的值执行第二步。所以这两个Python代码片段也是一样的：

```python
# The way we're used to seeing it:
result.append("hello")

# But this works the same:
append_result = result.append
append_result("hello")
```

在模板引擎代码中，我们以这种方式将其分开，以便无论我们执行第二步多少次，都只做一次第一步。这样可以节省了少量时间，因为我们避免花时间查找append属性。

这是微优化的例子：一种不寻常的编码技术，可以让我们在速度上获得微小的改进。但其可读性较差或者更混乱，因此它们仅仅是证明性能瓶颈的代码。这里的优化只在时序实验表明它们提高了性能之后才添加，虽然只是一点点。微型优化是有启发性的，因为它们可以利用Python的一些异乎寻常的方面，但不要在代码中过度使用。

`str`的捷径也是微优化。Python中的名称可以是函数的本地化，全局到一个模块，或者是内置到Python中。查找本地名称比查找全局或内置更快。我们习惯了`str`是一个可用的内建，但Python仍然需要在每次使用时查找名称`str`。把它放在一个地方，节省了我们另外一小段时间，因为当地人比内置的要快。

一旦定义了这些快捷方式，我们就可以准备好从我们特定模板创建的Python行。字符串使用`append_result`或`extend_result` shorthands添加到结果列表中，这取决于我们是否添加一个字符串或多个字符串。模板中的文字变成一个简单的字符串文字。

同时附加和扩展增加了复杂性，但请记住，我们的目标是最快地执行模板，使用项目的扩展意味着创建一个新项目列表，以便我们可以将其扩展。

计算`{{ ... }}`中的表达式，转换为字符串，并添加到结果中。表达式中的点由传递到我们的`do_dots`函数处理，因为虚线表达式的含义取决于上下文中的数据：它可以是属性访问或项目访问，可以是可调用的。

逻辑结构`{% if ... %}`和`{% for ... %}`转换为Python条件和循环。`{% if/for ... %}`标签中的表达式成为`if`或`for`语句中的表达式，直到`{% end... %}`标签的内容将成为语句的正文。

## 引擎代码

现在我们了解引擎将会做什么，让我们来看看怎么实现。

**Templite类**

模板引擎的核心是Templite类。

Templite类有一个很小的界面。你使用模板的文本构建一个Templite对象，然后可以使用其上的`render`方法通过模板呈现特定上下文（数据字典）：

```python
# Make a Templite object.
templite = Templite('''
    <h1>Hello {{name|upper}}!</h1>
    {% for topic in topics %}
        <p>You are interested in {{topic}}.</p>
    {% endfor %}
    ''',
    {'upper': str.upper},
)

# Later, use it to render some data.
text = templite.render({
    'name': "Ned",
    'topics': ['Python', 'Geometry', 'Juggling'],
})
```

创建对象时，我们传递模板的文本，以便我们可以仅执行一次编译步骤，然后再次调用`render`多次以重用编译结果。

构造函数也接受一个字典，一个初始化的文本。这些存储在Templite对象中，并且将在后面渲染模板时可用。这些对于定义我们希望在任何地方可用的函数或常量都很有用，像上一个例子中的`upper`一样。

在讨论Templite的实现之前，我们有一个帮助器来定义第一个：CodeBuilder。

**CodeBuilder**

我们引擎中的大部分工作是解析模板并生成必需的Python代码。为了帮助生成Python，我们构建CodeBuilder类，它在构建Python代码时处理bookkeeping 。它增加了一行代码，管理缩进，最后给出了从编译的Python的值。

一个CodeBuilder对象负责完整的Python代码块。由我们的模板引擎使用，大部分Python是一个完整的函数定义。但是CodeBuilder类不会假设它是一个函数。这样可以使CodeBuilder代码更加通用，而且与其他模板引擎代码的耦合较少。

我们使用嵌套的CodeBuilders来使代码运行在函数的开始，即使我们不知道它在完成之前是什么。

CodeBuilder对象保留最终Python代码的字符串列表。唯一需要的状态是当前的缩进级别：

```python
class CodeBuilder(object):
    """Build source code conveniently."""

    def __init__(self, indent=0):
        self.code = []
        self.indent_level = indent
```

CodeBuilder没有做很多。`add_line`添加了一行新代码，将文本自动缩进到当前的缩进级别，并提供换行符：

```python
    def add_line(self, line):
        """Add a line of source to the code.

        Indentation and newline will be added for you, don't provide them.

        """
        self.code.extend([" " * self.indent_level, line, "\n"])
```

`indent`和`dedent`增加或减少缩进级别：

```python
    INDENT_STEP = 4      # PEP8 says so!

    def indent(self):
        """Increase the current indent for following lines."""
        self.indent_level += self.INDENT_STEP

    def dedent(self):
        """Decrease the current indent for following lines."""
        self.indent_level -= self.INDENT_STEP
```

`add_section`由另一个CodeBuilder对象管理。这样我们可以保留代码中的引用，并在后面添加文本。`self.code`列表主要是字符串列表，但也保留对这些部分的引用：

```python
    def add_section(self):
        """Add a section, a sub-CodeBuilder."""
        section = CodeBuilder(self.indent_level)
        self.code.append(section)
        return section
```        

`__str__`生成一个包含所有代码的单个字符串。简单地将所有的字符串连接在`self.code`中。请注意，因为`self.code`包含部分，这可能会递归地调用其他`CodeBuilder`对象：

```python
    def __str__(self):
        return "".join(str(c) for c in self.code)
```

`get_globals`通过执行代码产生最终的值。这会对对象进行字符串处理，执行它以获取其定义，并返回生成的值：

```python
    def get_globals(self):
        """Execute the code, and return a dict of globals it defines."""
        # A check that the caller really finished all the blocks they started.
        assert self.indent_level == 0
        # Get the Python source as a single string.
        python_source = str(self)
        # Execute the source, defining globals, and return them.
        global_namespace = {}
        exec(python_source, global_namespace)
        return global_namespace
```

最后一种方法使用Python一些特殊的功能。`exec`函数执行包含Python代码的字符串。`exec`的第二个参数是一个字典，它将收集由代码定义的全局变量。 例如，如果我们这样做：

```python
python_source = """\
SEVENTEEN = 17

def three():
    return 3
"""
global_namespace = {}
exec(python_source, global_namespace)
```

`global_namespace['SEVENTEEN']`是17，而`global_namespace['three']`是`three`的实际函数。

虽然我们只使用CodeBuilder来生成函数，但是这里没有限制使用。这使得该类更容易实现，更容易理解。

CodeBuilder允许我们创建一个Python源代码，并且根本没有关于我们的模板引擎的具体知识。我们可以使用它在Python中定义三个不同的函数，然后`get_globals`将返回三个值的三个函数。就这样，我们的模板引擎只需要定义一个函数。但是，更好的软件设计可以实现细节保留在模板引擎代码中，并在CodeBuilder类之外。

即使我们使用它 —— 定义一个单一的函数 —— `get_globals`返回字典保持代码更加模块化，因为它不需要知道我们定义的函数的名称。无论我们在Python源代码中定义了什么函数名，我们可以从`get_globals`返回的`dict`中检索该名称。

现在我们可以进入Templite类本身的实现，看看如何使用CodeBuilder。

**Templite类实现**

我们的大部分代码都在Templite类中。正如我们所讨论的，它具有编译和渲染阶段。

**编译**

将模板编译成Python函数的所有工作都发生在Templite构造函数中。首先，保存文本：

```python
    def __init__(self, text, *contexts):
        """Construct a Templite with the given `text`.

        `contexts` are dictionaries of values to use for future renderings.
        These are good for filters and global values.

        """
        self.context = {}
        for context in contexts:
            self.context.update(context)
```

我们使用`*context`作为参数。星号表示任何数量的位置参数将被包装到元组中，并作为`contexts`传入。这被称为参数解包，并且意味着调用者可以提供许多不同的文本字典。 现在这些调用都是有效的：

```python
t = Templite(template_text)
t = Templite(template_text, context1)
t = Templite(template_text, context1, context2)
```

context参数（如果有的话）作为上下文的元组提供给构造函数。然后，遍历context元组，依次处理每个元组。我们简单地创建`elf.context`组合字典，它具有所有提供的context内容。如果在context中提供重复的名称，则最后一个获胜。

为了尽快编译函数，我们将context变量提取到Python本地。通过保留我们遇到的一组变量名来获取这些名称，但是还需要跟踪模板中定义的变量的名称，循环变量：

```python
        self.all_vars = set()
        self.loop_vars = set()
```

稍后我们将看到如何使用这些来帮助构建函数。首先，我们使用之前编写的CodeBuilder类开始构建编译的函数：

```python
        code = CodeBuilder()

        code.add_line("def render_function(context, do_dots):")
        code.indent()
        vars_code = code.add_section()
        code.add_line("result = []")
        code.add_line("append_result = result.append")
        code.add_line("extend_result = result.extend")
        code.add_line("to_str = str")
```

当我们创建需要进入编译函数的输出块时，我们需要将它们转换为附加到结果函数调用。我们希望将重复的附加调用合并到一个扩展调用中。这是另一个微优化。为了实现它，我们缓冲块。

`buffer`列表包含尚未写入我们的函数源代码的字符串。当模板继续编译时，我们将追加字符串到`buffered`，当到达控制流程点（如if语句）或循环的开始或结束时，将刷新到函数源。

`flush_output`函数是一个闭包，它引用了自身之外的变量。`flush_output`引用`buffered`和`code`。这简化了我们对函数的调用：我们不必告诉`flush_output`要刷新的缓冲区，或者在哪里刷新它;它知道所有隐含的。

如果仅缓冲一个字符串，则使用`append_result`将其加到结果上。如果多个缓冲区，则使用`extend_result`将其全部添加到结果中。然后缓冲列表被清除，因此可以缓冲更多的字符串。

代码的其余部分将它们附加到`buffered`，最后调用`flush_output`将它们写入CodeBuilder。

有了这个功能，有了下一行代码：

```python
buffered.append("'hello'")
```

这意味着我们编译的Python函数将有以下行：

```python
append_result('hello')
```

添加字符串`hello`到模板的渲染输出。我们在这里有多个抽象级别，难以直接处理。编译器使用`buffered.append("'hello'")`，它在编译的Python函数中创建`append_result('hello')`，运行时，它会附加`hello`到结果上。

回到Templite类。解析控制结构时，我们要检查它们是否正确嵌套。`ops_stack`列表是一串字符串：

```python
        ops_stack = []
```

当遇到`{% if .. %}`标签时，我们把`"if"`推到堆上。当找到`{% endif %}`标签时，如果堆顶部没有`"if"`，弹出堆并报告错误。

现在真正的解析开始了。我们使用正则表达式将模板文本拆分成多快。正则表达式可能令人生畏：它们是复杂模式匹配的非常紧凑的符号。 它们也是非常有效的，因为复杂的匹配模式是在正则表达式引擎中的C中实现的，而不是在Python代码中实现的。这是我们的正则表达式：

```python
        tokens = re.split(r"(?s)({{.*?}}|{%.*?%}|{#.*?#})", text)
```

这看起来很复杂 让我们来分解说明。

`re.split`函数使用正则表达式拆分字符串。我们的模式是括号，所以匹配将用于拆分字符串，片段返回到拆分列表。模式符合我们的标签语法，但是我们加了括号，以便字符串将在标签中分割，并且还将返回标签。

正则表达式中的`(?s)`表示一个点匹配换行符。接下来，我们有三个备选方案的括号组：`{{.*?}}`匹配一个表达式，`{%.*?%}`匹配一个标签，`{#.*?#}`匹配一个注释。 我们使用`.*?`匹配任意数量的字符，但匹配成的最短序列。

`re.split`的结果是字符串列表。例如，这个模板文本：

```python
<p>Topics for {{name}}: {% for t in topics %}{{t}}, {% endfor %}</p>
```

将被分成这些部分：

```python
[
    '<p>Topics for ',               # literal
    '{{name}}',                     # expression
    ': ',                           # literal
    '{% for t in topics %}',        # tag
    '',                             # literal (empty)
    '{{t}}',                        # expression
    ', ',                           # literal
    '{% endfor %}',                 # tag
    '</p>'                          # literal
]
```

一旦文本被分成这样的片段，我们可以循环使用tokens，并依次处理每个token。根据类型拆分，我们可以分别处理每种类型。

编译代码是循环使用这些tokens：

```python
        for token in tokens:
```

检查每个token以查看是四种情况中的哪一种。只看前两个字符就可以了。第一种情况是一个注释，很容易处理：只要忽略它并移动到下一个token：

```python
            if token.startswith('{#'):
                # Comment: ignore it and move on.
                continue
```

`{{...}}`表达式的情况，我们在前面和后面切断了两个大括号，剥离了空白处，并将整个表达式传递给`_expr_code`：

```python
            elif token.startswith('{{'):
                # An expression to evaluate.
                expr = self._expr_code(token[2:-2].strip())
                buffered.append("to_str(%s)" % expr)
```

`_expr_code`函数将模板表达式编译成Python表达式。稍后会看到。我们使用`to_str`函数强制表达式的值为一个字符串，并将其添加到结果中。

第三种情况是`{% ... %}`标签。这些将成为Python的控制结构。首先我们要刷新缓冲输出行，然后从标签中提取一个单词列表：

```python
            elif token.startswith('{%'):
                # Action tag: split into words and parse further.
                flush_output()
                words = token[2:-2].strip().split()
```

有三个子案例，基于标签中的第一个字：`if`，`for`或`end`。`if`显示我们简单的错误处理和代码生成：

```python
                if words[0] == 'if':
                    # An if statement: evaluate the expression to determine if.
                    if len(words) != 2:
                        self._syntax_error("Don't understand if", token)
                    ops_stack.append('if')
                    code.add_line("if %s:" % self._expr_code(words[1]))
                    code.indent()
```

`if`标签如果有单一的表达式，所以单词列表应该只有两个元素。如果没有，我们使用`_syntax_error`方法抛出语法错误异常。我们将`'if'`推到`ops_stack`上，以便检查`endif`标签。`if`标签的表达式部分使用`_expr_code`编译为Python表达式，并用作Python `if`语句的条件表达式。

第二个标签类型是`for`，被编译为Python `for`语句：

```python
                elif words[0] == 'for':
                    # A loop: iterate over expression result.
                    if len(words) != 4 or words[2] != 'in':
                        self._syntax_error("Don't understand for", token)
                    ops_stack.append('for')
                    self._variable(words[1], self.loop_vars)
                    code.add_line(
                        "for c_%s in %s:" % (
                            words[1],
                            self._expr_code(words[3])
                        )
                    )
                    code.indent()
```

我们检查语法，并将`'for'`推到堆栈上。`_variable`函数检查变量的语法，并将其添加到我们提供的集合中。这是在编译时收集所有变量的名称。稍后我们将需要编写我们函数的前言，我在这里打开我们从context获得的所有变量名。为了做到这一点，我们需要知道我们遇到的所有变量的名称，`self.all_vars`以及由`self.loop_vars`循环定义的所有变量的名称。

我们在函数源中添加一行`for`语句。所有的模板变量通过向它们前面添加`c_`而变成Python变量，以便它们不会与我们在Python函数中使用的其他名称相冲突。我们使用`_expr_code`迭代表达式从模板编译成Python中的迭代表达式。

我们处理的最后一个标签是`end`; `{% endif %}`或`{% endfor %}`。对我们编译的函数源影响是一样的：简单地取消结束前面提到的`if`或`for`语句：

```python
                elif words[0].startswith('end'):
                    # Endsomething.  Pop the ops stack.
                    if len(words) != 1:
                        self._syntax_error("Don't understand end", token)
                    end_what = words[0][3:]
                    if not ops_stack:
                        self._syntax_error("Too many ends", token)
                    start_what = ops_stack.pop()
                    if start_what != end_what:
                        self._syntax_error("Mismatched end tag", end_what)
                    code.dedent()
```

请注意，结束标签所需的实际工作是：取消缩进功能源。此子句的其余部分都是错误检查，以确保正确形成模板。这并不罕见。

说到错误处理，如果标签不是`if`，`for`或`end`，那么我们不知道它是什么，则引发语法错误：

```python
                else:
                    self._syntax_error("Don't understand tag", words[0])
```

我们完成了三种不同的特殊语法（`{{...}}`，`{#...#}`和`{%...%}`）。剩下的是文字内容。我们将文字字符串添加到缓冲输出，使用`repr`内置函数为toekn生成Python字符串：

```python
            else:
                # Literal content.  If it isn't empty, output it.
                if token:
                    buffered.append(repr(token))
```

如果我们没有使用`repr`，那么在编译的函数中会有这样一行：

```python
append_result(abc)      # Error! abc isn't defined
```

我们需要引用值：

```python
append_result('abc')
```

`repr`函数为我们提供围绕字符串的引号，并在需要时提供反斜杠：

```python
append_result('"Don\'t you like my hat?" he asked.')
```

我们首先用`if taken:`检查token是否为空字符串,因为是，指向输出添加空字符串。因为我们的正则表达式是在标签上分裂的，所以相邻的标签之间有一个空的标记。这里的检查方法很简单，避免将无用的`append_result("")`语句放入我们的函数中。

这完成了模板中所有tokens的循环。循环完成后，处理完毕所有的模板。我们最后检查一下：如果`ops_stack`不为空，则缺少一个结束标签。然后我们将缓冲输出刷新到函数源：

```python
        if ops_stack:
            self._syntax_error("Unmatched action tag", ops_stack[-1])

        flush_output()
```

我们在函数开头创建了一个部分。它的作用是将模板变量从context解压缩到Python本地。现在我们已经处理了整个模板，知道了所有变量的名称，所以我们可以在前面写出。

我们必须知道我们需要定义什么名字。来看看我们的示例模板：

```html
<p>Welcome, {{user_name}}!</p>
<p>Products:</p>
<ul>
{% for product in product_list %}
    <li>{{ product.name }}:
        {{ product.price|format_price }}</li>
{% endfor %}
</ul>
```

这里有两个变量，`user_name`和`product`。`all_vars`集有这两个名称，因为它们都在`{{...}}`表达式中使用。 但是，只有`user_name`需要从context前面中提取，因为`product`是由循环定义的。

模板中使用的所有变量都在`set all_vars`中，模板中定义的所有变量都在`loop_vars`中。`loop_vars`中的所有名字已经在代码中定义，因为它们在循环中使用。所以我们需要在不在`loop_vars`中的`all_vars`中解压缩所有名称：

```python
        for var_name in self.all_vars - self.loop_vars:
            vars_code.add_line("c_%s = context[%r]" % (var_name, var_name))
```

每个名称在函数的序言的一行，将context变量解包成一个适当命名的局部变量。

我们几乎将模板都编译成Python函数。函数已经将字符串附加到结果中，所以函数的最后一行只是合并它们并返回：

```python
        code.add_line("return ''.join(result)")
        code.dedent()
```

现在我们已经编写了Python函数的源代码，我们需要从CodeBuilder对象获取函数本身。`get_globals`函数执行我们已经组装的Python代码。我们的代码是一个函数（从`def render_function(..):`开始)，所以执行代码定义`render_function`，但不执行`render_function`的正文。

`get_globals`的结果是代码中定义的字典。我们从中获取`render_function`值，并将其保存为Templite对象中的属性：

```python
        self._render_function = code.get_globals()['render_function']
```

现在`self._render_function`是一个可调用的Python函数。稍后我们将在渲染阶段使用它。

**编译表达式**

我们还没有看到一个重要的编译过程：`_expr_code`函数将模板表达式编译成Python表达式。我们的模板表达式可以像单一名称简单：

```python
{{user_name}}
```

或者是属性访问和过滤器的复杂序列：

```python
{{user.name.localized|upper|escape}}
```

`_expr_code`处理所有可能性。与其他编程语言的表达式一样，递归构建：大表达式由较小的表达式组成。一个完整的表达式是管道分隔的，第一个是点分隔的，依此类推。所以函数自然会采用递归的形式：

```python
    def _expr_code(self, expr):
        """Generate a Python expression for `expr`."""
```

要考虑的第一个例子是我们的表达式有管道。如果是这样，那么我们把它分成管道列表。第一个管道递归地传递给`_expr_code`，将其转换为Python表达式。

```python
        if "|" in expr:
            pipes = expr.split("|")
            code = self._expr_code(pipes[0])
            for func in pipes[1:]:
                self._variable(func, self.all_vars)
                code = "c_%s(%s)" % (func, code)
```

剩余的管道是功能的名称。该值通过函数传递产生最终值。 每个函数名称是一个变量，被添加到`all_vars`中，以便我们可以在序言中正确调用。

如果没有管道，可能是点。如果是这样，把点分开。第一部分将递归传递给`_expr_code`以转换为Python表达式，然后依次处理每个点名称：

```python
        elif "." in expr:
            dots = expr.split(".")
            code = self._expr_code(dots[0])
            args = ", ".join(repr(d) for d in dots[1:])
            code = "do_dots(%s, %s)" % (code, args)
```

要了解点如何编译，模板中的`x.y`意味着Python中的`x['y']`或`x.y`，具体取决于什么;如果结果是可调用的，则调用。这种不确定性意味着我们必须在运行时尝试各种运行时间，而不是编译时间。所以我们将`x.y.z`编译给`do_dots(x, 'y', 'z')`调用。点函数尝试各种访问方法并返回成功的值。

运行时，`do_dots`函数被传递到编译的Python函数中。我们稍后会看到它的实现。

`_expr_code`函数中的最后一个子句处理输入表达式中没有管道或点的情况。这种情况下，只是一个名字。我们将其记录在`all_vars`中，并使用其前缀Python名称访问变量：

```python
        else:
            self._variable(expr, self.all_vars)
            code = "c_%s" % expr
        return code
```

**Helper Functions**

编译期间，我们使用了几个帮助函数。`_syntax_error`函数简单地组合了很好的错误消息并引发异常：

```python
    def _syntax_error(self, msg, thing):
        """Raise a syntax error using `msg`, and showing `thing`."""
        raise TempliteSyntaxError("%s: %r" % (msg, thing))
```

`_variable`函数帮助我们验证变量名称并将其添加到我们在编译期间收集的名字集合。我们使用正则表达式来检查名字是否是有效的Python标识符，然后将名称添加到集合中：

``python
    def _variable(self, name, vars_set):
        """Track that `name` is used as a variable.

        Adds the name to `vars_set`, a set of variable names.

        Raises an syntax error if `name` is not a valid name.

        """
        if not re.match(r"[_a-zA-Z][_a-zA-Z0-9]*$", name):
            self._syntax_error("Not a valid name", name)
        vars_set.add(name)
```

编译代码完成了！

**Rendering**

剩下的就是渲染代码。由于我们已经将我模板编译成了一个Python函数，所以渲染代码没有太多事要做。它必须准备好数据context，然后调用编译的Python代码：

```python
    def render(self, context=None):
        """Render this template by applying it to `context`.

        `context` is a dictionary of values to use in this rendering.

        """
        # Make the complete context we'll use.
        render_context = dict(self.context)
        if context:
            render_context.update(context)
        return self._render_function(render_context, self._do_dots)
```

请记住，当我们构建`Templite`对象时，我们从数据context开始。在这里复制它，并合并到传递的数据进行渲染。复制是这样的，连续的渲染调用不会看到彼此的数据，合并是为了构建一个字典用于数据查找。这是我们如何从构建模板时提供的context构建一个统一的数据context，在渲染时提供数据。

请注意，传递给`render`的数据覆盖传递给`Templite`构造函数。这往往不会发生，因为传递给构造函数的context具有全局属性，例如过滤器定义和常量，传递给`render`的context具有`render`的特定数据。

然后我们简单地调用编译的`render_function`。第一个参数是完整的数据context，第二个参数是实现点语义的函数。我们每次使用相同的实现：`_do_dots`函数。

```python
    def _do_dots(self, value, *dots):
        """Evaluate dotted expressions at runtime."""
        for dot in dots:
            try:
                value = getattr(value, dot)
            except AttributeError:
                value = value[dot]
            if callable(value):
                value = value()
        return value
```

编译期间，像`x.y.z`这样的模板表达式变为`do_dots(x, 'y', 'z')`。此函数循环遍历点名称，并且每个都将其作为属性进行循环，如果失败，则尝试将其作为关键字。这就是我们的单一模板语法可以作为`x.y`或`x['y']`的灵活性。在每个步骤，我们还检查新值是否可调用，如果是，调用它。一旦我们遍历万所有的点名称，值便是我们想要的。

这里我们再次使用Python参数解包（`*dot`），以便`_do_dots`可以获取任意数量的点名称。这给我们一个灵活的功能，可以用于我们在模板中遇到的任何虚线表达。

请注意，当调用`self._render_function`时，我们传递一个函数来用于评估点表达式。我们可以将该代码作为编译模板的一部分，但是对于每个模板而言，它们都是八行，而这八行是模板函数的定义的一部分，而不是特定模板的一部分细节。像这样实现它比将编码作为编译模板的一部分感觉更清洁。

## 测试

提供覆盖模板引擎所有行为和边缘案例的测试。实际上超过了500行代码限制：模板引擎是252行，测试是275行。这是经过良好测试的代码的典型代码：您的测试中有更多的代码。

## 还漏了什么

全功能的模板引擎比我们在这里实现的还要多。为了保持少代码，我们留了写有趣的想法：

* 模板继承和包含

* 自定义标签

* 自动转义

* 滤镜参数

* 复杂的条件逻辑，如else和elif

* 具有多个循环变量的循环

* 空白操作

即使如此，我们的简单模板引擎也很有用。实际上，这是`coverage.py`中使用的模板引擎来生成HTML报告。

## 总结

在252行中，我们有一个简单而有能力的模板引擎。真正的模板引擎有更多的功能，但是这个代码阐述了这个过程的基本思想：将模板编译成Python函数，然后执行该函数来产生文本结果。

